#!/usr/bin/env node

// Simple debug version with better error handling
const fs = require('fs');
const path = require('path');

console.log('ðŸš€ Starting React Modularizer...\n');

// Check Node version
console.log('Node version:', process.version);

// Check if required modules exist
try {
  const parser = require('@babel/parser');
  const traverse = require('@babel/traverse').default;
  const generate = require('@babel/generator').default;
  const prettier = require('prettier');
  console.log('âœ… All dependencies loaded\n');
} catch (error) {
  console.error('âŒ Missing dependencies:', error.message);
  console.log('Run: npm install @babel/parser @babel/traverse @babel/generator prettier');
  process.exit(1);
}

class ReactModularizer {
  constructor() {
    this.extractedComponents = [];
    this.imports = [];
    this.appFilePath = './App.jsx';
    this.componentsDir = './components';
  }

  async run() {
    try {
      console.log('Step 1: Checking App.jsx...');
      
      // Check if App.jsx exists
      if (!fs.existsSync(this.appFilePath)) {
        console.error('âŒ App.jsx not found in current directory');
        console.log('Current directory:', process.cwd());
        console.log('Files in directory:', fs.readdirSync('.'));
        process.exit(1);
      }
      
      console.log('âœ… App.jsx found');
      
      // Read file
      console.log('Step 2: Reading file...');
      const content = fs.readFileSync(this.appFilePath, 'utf8');
      console.log('âœ… File read successfully');
      console.log('File size:', content.length, 'characters');
      
      // Try to parse
      console.log('Step 3: Parsing code...');
      const parser = require('@babel/parser');
      const ast = parser.parse(content, {
        sourceType: 'module',
        plugins: ['jsx', 'typescript']
      });
      console.log('âœ… Code parsed successfully');
      
      // Extract components
      console.log('Step 4: Finding components...');
      this.extractComponents(ast);
      
      if (this.extractedComponents.length === 0) {
        console.log('â„¹ï¸  No extractable components found');
        return;
      }
      
      console.log(`âœ… Found ${this.extractedComponents.length} components`);
      
      // Create directory
      console.log('Step 5: Creating components directory...');
      this.ensureComponentsDirectory();
      
      // Write files
      console.log('Step 6: Writing component files...');
      await this.writeComponentFiles();
      
      // Update App.jsx
      console.log('Step 7: Updating App.jsx...');
      const updatedContent = await this.updateAppFile(ast);
      fs.writeFileSync(this.appFilePath, updatedContent, 'utf8');
      
      console.log('âœ… Modularization complete!');
      this.showResults();
      
    } catch (error) {
      console.error('ðŸ’¥ Error occurred:');
      console.error('Error message:', error.message);
      console.error('Stack trace:', error.stack);
      process.exit(1);
    }
  }

  extractComponents(ast) {
    const traverse = require('@babel/traverse').default;
    const generate = require('@babel/generator').default;
    
    const componentsToRemove = [];
    
    traverse(ast, {
      FunctionDeclaration: (path) => {
        const name = path.node.id?.name;
        
        if (this.isExtractableComponent(name)) {
          const code = generate(path.node, {}, '').code;
          
          this.extractedComponents.push({
            name,
            code,
            type: 'function'
          });
          
          this.imports.push(`import ${name} from './components/${name}';`);
          componentsToRemove.push(path);
          
          console.log(`  âœ“ Found: ${name}`);
        }
      },
      
      VariableDeclaration: (path) => {
        path.node.declarations.forEach(declarator => {
          const name = declarator.id?.name;
          
          if (name && 
              (declarator.init?.type === 'ArrowFunctionExpression' || 
               declarator.init?.type === 'FunctionExpression') &&
              this.isExtractableComponent(name)) {
            
            const code = generate(path.node, {}, '').code;
            
            this.extractedComponents.push({
              name,
              code,
              type: 'arrow'
            });
            
            this.imports.push(`import ${name} from './components/${name}';`);
            componentsToRemove.push(path);
            
            console.log(`  âœ“ Found: ${name}`);
          }
        });
      }
    });
    
    // Remove components from AST
    componentsToRemove.forEach(path => path.remove());
  }

  isExtractableComponent(name) {
    return name && 
           name[0] === name[0].toUpperCase() && 
           name !== 'App' &&
           name.length > 1;
  }

  ensureComponentsDirectory() {
    if (!fs.existsSync(this.componentsDir)) {
      fs.mkdirSync(this.componentsDir, { recursive: true });
      console.log('âœ… Components directory created');
    }
  }

  async writeComponentFiles() {
    for (const component of this.extractedComponents) {
      try {
        const fileName = `${component.name}.jsx`;
        const filePath = path.join(this.componentsDir, fileName);
        
        let exportCode = "import React from 'react';\n\n";
        
        if (component.type === 'function') {
          exportCode += component.code.replace(/^function\s+\w+/, `export default function ${component.name}`);
        } else {
          exportCode += `${component.code};\n\nexport default ${component.name};`;
        }
        
        // Try to format with prettier, if it fails use unformatted
        try {
          const prettier = require('prettier');
          exportCode = await prettier.format(exportCode, {
            parser: 'babel',
            semi: true,
            singleQuote: true,
            tabWidth: 2
          });
        } catch (prettierError) {
          console.warn(`âš ï¸  Prettier failed for ${fileName}, using unformatted code`);
        }
        
        fs.writeFileSync(filePath, exportCode, 'utf8');
        console.log(`  âœ… Created: ${fileName}`);
        
      } catch (fileError) {
        console.error(`âŒ Failed to write ${component.name}:`, fileError.message);
      }
    }
  }

  async updateAppFile(ast) {
    const generate = require('@babel/generator').default;
    
    let updatedContent = generate(ast, {}, '').code;
    
    if (this.imports.length > 0) {
      const lines = updatedContent.split('\n');
      let insertIndex = 0;
      
      // Find where to insert imports
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].trim().startsWith('import ')) {
          insertIndex = i + 1;
        } else if (lines[i].trim() && !lines[i].trim().startsWith('import ')) {
          break;
        }
      }
      
      lines.splice(insertIndex, 0, '', ...this.imports);
      updatedContent = lines.join('\n');
    }
    
    // Try to format
    try {
      const prettier = require('prettier');
      return await prettier.format(updatedContent, {
        parser: 'babel',
        semi: true,
        singleQuote: true,
        tabWidth: 2
      });
    } catch (error) {
      console.warn('âš ï¸  Prettier failed for App.jsx, using unformatted code');
      return updatedContent;
    }
  }

  showResults() {
    console.log('\nðŸŽ¯ RESULTS:');
    console.log(`âœ… Extracted ${this.extractedComponents.length} components`);
    this.extractedComponents.forEach(comp => {
      console.log(`  - ${comp.name}.jsx`);
    });
    console.log('âœ… Updated App.jsx with imports');
  }
}

// Run the tool
if (require.main === module) {
  const modularizer = new ReactModularizer();
  modularizer.run();
}

module.exports = ReactModularizer;
